unit TestAhoCorasick;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit
  being tested.

}

interface

uses
  TestFramework, System.Classes, AhoCorasick.Interval, System.Generics.Collections,
  System.Generics.Defaults, AhoCorasick.Trie, AhoCorasick.DoubleArrayTrie;

type
  TestTInterval = class(TTestCase)
  strict private
    FInterval: TInterval;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestOverlapsWith1;
  end;

  TestTIntervalTree = class(TTestCase)
  strict private
    FIntervalTree: TIntervalTree;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestRemoveOverlaps;
    procedure TestFindOverlaps;
  end;

  TestTEmit = class(TTestCase)
  published
    procedure TestEqual;
  end;

  // Test methods for class TState
  TestTState = class(TTestCase)
  strict private
    FState: TState;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestDepth;
  end;

  // Test methods for class TTrie
  TestTTrie = class(TTestCase)
  strict private
    FTrie: TTrie;
  public
    procedure SetUp; override;
    procedure TearDown; override;
    procedure CheckEmit(aNext: TEmit; aExpectedStart, aExpectedEnd: Integer;
      aExpectedKeyword: string);
  published
    procedure TestParseSameOrLonger;
    procedure TestParseUshers;
    procedure PressTestParse;
    procedure MisleadingTest;
    procedure NonOverlapping;

    procedure PartialMatch;
    procedure TestTokenize;
    procedure ZeroLengthTest;
  end;

  // Test methods for class TDoubleArrayTrie
  TestTDoubleArrayTrie = class(TTestCase)
  strict private
    FDoubleArrayTrie: TDoubleArrayTrie;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure PressTest;
  end;

implementation

uses
  System.SysUtils, System.Diagnostics;

procedure TestTInterval.SetUp;
begin
  FInterval := TInterval.Create(1, 3);
end;

procedure TestTInterval.TearDown;
begin
  FInterval.Free;
  FInterval := nil;
end;

procedure TestTInterval.TestOverlapsWith1;
var
  ReturnValue: Boolean;
  APoint: Integer;
  LItl: TInterval;
begin
  APoint := 2;
  ReturnValue := FInterval.OverlapsWith(APoint);
  Status(Format('[%s] Overlaps [%d] : %s Expected[True]', [FInterval.ToString, APoint,
    BoolToStr(ReturnValue)]));

  LItl := TInterval.Create(2, 4);
  ReturnValue := FInterval.OverlapsWith(LItl);
  Status(Format('[%s] Overlaps [%s] : %s Expected[True]', [FInterval.ToString, LItl.ToString,
    BoolToStr(ReturnValue)]));
  LItl.Free;
end;

procedure TestTIntervalTree.SetUp;
var
  LItls: TList<TInterval>;
begin
  LItls := TList<TInterval>.Create;
  LItls.add(TInterval.Create(0, 2));
  LItls.add(TInterval.Create(1, 3));
  LItls.add(TInterval.Create(2, 4));
  LItls.add(TInterval.Create(3, 5));
  LItls.add(TInterval.Create(4, 6));
  LItls.add(TInterval.Create(5, 7));

  FIntervalTree := TIntervalTree.Create(LItls);

  LItls.Free;
end;

procedure TestTIntervalTree.TearDown;
begin
  FIntervalTree.Free;
  FIntervalTree := nil;
end;

procedure TestTIntervalTree.TestRemoveOverlaps;
var
  LItls: TList<TInterval>;
  LItlTree: TIntervalTree;
  LItl: TInterval;
begin
  LItls := TList<TInterval>.Create;
  LItls.add(TInterval.Create(0, 2));
  LItls.add(TInterval.Create(4, 5));
  LItls.add(TInterval.Create(2, 10));
  LItls.add(TInterval.Create(6, 13));
  LItls.add(TInterval.Create(9, 15));
  LItls.add(TInterval.Create(12, 16));

  LItlTree := TIntervalTree.Create(LItls);
  LItlTree.RemoveOverlaps(LItls);
  CheckTrue(2 = LItls.Count, '错误,期望值2');
  for LItl in LItls do
  begin
    Status(Format('结果值: %s', [LItl.ToString]));
  end;

  LItls.Free;
  LItlTree.Free;
end;

procedure TestTIntervalTree.TestFindOverlaps;
var
  ReturnValue: TList<TInterval>;
  AItl: TInterval;
begin
  AItl := TInterval.Create(1, 3);
  ReturnValue := FIntervalTree.FindOverlaps(AItl);
  CheckTrue(3 = ReturnValue.Count, '错误,期望值为3');
  AItl.Free;

  Status('期望值: [2,4] [3,5] [0,2]');
  for AItl in ReturnValue do
  begin
    Status(Format('结果值: %s', [AItl.ToString]));
  end;
end;

{ TestTEmit }

procedure TestTEmit.TestEqual;
var
  LE1, LE2: TEmit;
begin
  LE1 := TEmit.Create(13, 42, 'a');
  LE2 := TEmit.Create(13, 42, '');
  CheckTrue(LE1.Equal(LE2), '期望值为True');
  CheckTrue(LE1.Equals(LE2), '期望值为True');
  LE1.Free;
  LE2.Free;

  LE1 := TEmit.Create(13, 42, 'a');
  LE2 := TEmit.Create(13, 43, 'a');
  CheckFalse(LE1.Equal(LE2), '期望值为False');
  CheckFalse(LE1.Equals(LE2), '期望值为False');
  LE1.Free;
  LE2.Free;
end;

procedure TestTState.SetUp;
begin
  FState := TState.Create(0);
  FState.AddLeaf(Char('a')).AddLeaf(Char('b')).AddLeaf(Char('c'));
end;

procedure TestTState.TearDown;
begin
  FState.Free;
  FState := nil;
end;

procedure TestTState.TestDepth;
var
  LCurr: TState;
begin
  LCurr := FState.GotoLeaf(Char('a'));
  CheckTrue(1 = LCurr.Depth, '期望值:1');
  LCurr := LCurr.GotoLeaf(Char('b'));
  CheckTrue(2 = LCurr.Depth, '期望值:2');
  LCurr := LCurr.GotoLeaf(Char('c'));
  CheckTrue(3 = LCurr.Depth, '期望值:3');
end;

procedure TestTTrie.SetUp;
begin
  FTrie := TTrie.Create;
end;

procedure TestTTrie.TearDown;
begin
  FTrie.Free;
  FTrie := nil;
end;

procedure TestTTrie.CheckEmit(aNext: TEmit; aExpectedStart, aExpectedEnd: Integer;
  aExpectedKeyword: string);
begin
  CheckEquals(aExpectedStart, aNext.GetStart, 'Start of emit should have been' +
    aExpectedStart.ToString);
  CheckEquals(aExpectedEnd, aNext.GetEnd, 'End of emit should have been' + aExpectedEnd.ToString);
  CheckEquals(aExpectedKeyword, aNext.Keyword, 'Start of emit should have been' + aExpectedKeyword);
end;

procedure TestTTrie.TestParseSameOrLonger;
var
  LEmits: TList<TEmit>;
  LText: string;
begin
  FTrie.AddKeyword('啊哦呃');
  LText := '啊哦呃';
  LEmits := FTrie.ParseText(LText);
  CheckEmit(LEmits[0], 1, 3, LText);
  Status(LEmits[0].ToString);

  LText := ' 啊哦呃';
  LEmits := FTrie.ParseText(LText);
  CheckEmit(LEmits[0], 2, 4, '啊哦呃');
  Status(LEmits[0].ToString);

  FTrie.OnlyWholeWords;
  FTrie.AddKeyword('this');
  LText := string('LİKE THIS').Substring(5, 8); //下标从0开始
  LText := 'LİKE THIS';  // The second character ('İ') is Unicode, which was read by AC as a 2-byte char
  LEmits := FTrie.ParseText('LİKE THIS');
  CheckEmit(LEmits[0], 6, 9, 'this');
  Status(LEmits[0].ToString);
end;

procedure TestTTrie.TestParseUshers;
var
  ReturnValue: TList<TEmit>;
  aText: string;
  LEmit: TEmit;
begin
  FTrie.AddKeyword('hers');
  FTrie.AddKeyword('his');
  FTrie.AddKeyword('she');
  FTrie.AddKeyword('he');
  aText := 'ushers';
  ReturnValue := FTrie.ParseText(aText);
  CheckEquals(3, ReturnValue.Count); // she @ 3, he @ 3, hers @ 5
  CheckEmit(ReturnValue[0], 2, 4, 'she');
  CheckEmit(ReturnValue[1], 3, 4, 'he');
  CheckEmit(ReturnValue[2], 3, 6, 'hers');
  for LEmit in ReturnValue do
  begin
    Status(LEmit.ToString);
  end;
end;

procedure TestTTrie.PressTestParse;
const
  RES      = '..\..\Resource\dictionary.txt';
  PRESSURE = 100000;
var
  LKeys, LText: string;
  LWatch: TStopwatch;
  LEmits: TList<TEmit>;
  LEmit: TEmit;
  I: Integer;
  LBlack: Boolean;
begin
  LWatch := TStopwatch.StartNew;
  FTrie.AddKeyword('啊哈');
  FTrie.Init(RES);
  Status(Format('添加: 关键词条数 %d, 耗时 %d ms', [120000, LWatch.ElapsedMilliseconds]));

  LText := '一词T%^he 两!@#$#%%^^*词qu %^ick 啊哈哈!@#$#三词br%^　own 第!@#$#四次fox' +
    '五jum!@#$#ps词 六ov!@#$#er词 7词th!@#$#e 8词la!@#$#zy 9词do!@#$#g';
  LWatch := TStopwatch.StartNew;
  for I := 0 to PRESSURE do
    LBlack := FTrie.HasBlackWord(LText);
  Status(Format('HasBlackWord: 语句长度 %d, %d次耗时 %d ms 是否有屏蔽字-%s', [LText.Length, PRESSURE,
    LWatch.ElapsedMilliseconds, BoolToStr(LBlack)]));

  LWatch := TStopwatch.StartNew;
  for I := 0 to PRESSURE do
    LKeys := FTrie.Filter(LText);
  Status(Format('Filter: 语句长度 %d, %d次耗时 %d ms', [LText.Length, PRESSURE,
    LWatch.ElapsedMilliseconds]));
  Status(LKeys);

  LText := 'The quick brown fox jumps over the lazy dog';
  LWatch := TStopwatch.StartNew;
  for I := 0 to PRESSURE do
    LEmits := FTrie.ParseText(LText);
  Status(Format('解析: 语句长度 %d, %d次耗时 %d ms', [LText.Length, PRESSURE, LWatch.ElapsedMilliseconds]));
  for LEmit in LEmits do
  begin
    Status(LEmit.ToString);
  end;
end;

procedure TestTTrie.MisleadingTest;
var
  LEmits: TList<TEmit>;
begin
  FTrie.AddKeyword('hers');
  LEmits := FTrie.ParseText('h he her hers');
  CheckEmit(LEmits[0], 10, 13, 'hers');
  Status(LEmits[0].ToString);
end;

procedure TestTTrie.NonOverlapping;
var
  LEmits: TList<TEmit>;
begin
  FTrie.RemoveOverlaps;
  FTrie.AddKeyword('ab');
  FTrie.AddKeyword('cba');
  FTrie.AddKeyword('ababc');
  LEmits := FTrie.ParseText('ababcbab');
  // With overlaps: ab@1, ab@3, ababc@4, cba@6, ab@7
  CheckEquals(2, LEmits.Count);
  CheckEmit(LEmits[0], 1, 5, 'ababc');
  Status(LEmits[0].ToString);
  CheckEmit(LEmits[1], 7, 8, 'ab');
  Status(LEmits[1].ToString);

  // startOfChurchillSpeech
  FTrie.AddKeyword('T');
  FTrie.AddKeyword('u');
  FTrie.AddKeyword('ur');
  FTrie.AddKeyword('r');
  FTrie.AddKeyword('urn');
  FTrie.AddKeyword('ni');
  FTrie.AddKeyword('i');
  FTrie.AddKeyword('in');
  FTrie.AddKeyword('n');
  FTrie.AddKeyword('urning');

  LEmits := FTrie.ParseText('Turning');
  CheckEquals(2, LEmits.Count);
  Status('StartOfChurchillSpeech:');
  Status(LEmits[0].ToString);
  Status(LEmits[1].ToString);
end;

procedure TestTTrie.PartialMatch;
var
  LEmits: TList<TEmit>;
  LEmit: TEmit;
begin
  FTrie.OnlyWholeWords;
  FTrie.AddKeyword('sugar');
  LEmits := FTrie.ParseText('%sugarcane sugarcane sugar canesugar');
  CheckEquals(1, LEmits.Count);
  Status(LEmits[0].ToString);
  CheckEmit(LEmits[0], 22, 26, 'sugar');

  Status('Unicode大小写测试:TurninG OnCe AgAiN BÖRKÜ');
  FTrie.AddKeyword('turning');
  FTrie.AddKeyword('once');
  FTrie.AddKeyword('again');
  FTrie.AddKeyword('börkü');
  LEmits := FTrie.ParseText('TurninG OnCe AgAiN BÖRKÜ');
  CheckEquals(4, LEmits.Count); // Match must not be made
  CheckEmit(LEmits[0], 1, 7, 'turning');
  CheckEmit(LEmits[1], 9, 12, 'once');
  CheckEmit(LEmits[2], 14, 18, 'again');
  CheckEmit(LEmits[3], 20, 24, 'börkü');
  for LEmit in LEmits do
  begin
    Status(LEmit.ToString);
  end;
end;

procedure TestTTrie.TestTokenize;
var
  LTokens: TList<TToken>;
  LToken: TToken;
begin
  FTrie.AddKeyword('Alpha');
  FTrie.AddKeyword('Beta');
  FTrie.AddKeyword('Gamma');
  LTokens := FTrie.Tokenize('Hear: Alpha team first, Beta from the rear, Gamma in reserve');
  CheckEquals(7, LTokens.Count);
  CheckEquals('Hear: ', LTokens[0].Fragment);
  CheckEquals('Alpha', LTokens[1].Fragment);
  CheckEquals(' team first, ', LTokens[2].Fragment);
  CheckEquals('Beta', LTokens[3].Fragment);
  CheckEquals(' from the rear, ', LTokens[4].Fragment);
  CheckEquals('Gamma', LTokens[5].Fragment);
  CheckEquals(' in reserve', LTokens[6].Fragment);
  for LToken in LTokens do
  begin
    Status(LToken.Fragment);
  end;
end;

procedure TestTTrie.ZeroLengthTest;
var
  LTokens: TList<TToken>;
  LToken: TToken;
begin
  FTrie.RemoveOverlaps;
  FTrie.OnlyWholeWords;
  
  FTrie.AddKeyword('');
  LTokens := FTrie.tokenize('Try a natural lip and subtle bronzer to keep all the focus on ' + 
    'those big bright eyes with NARS Eyeshadow Duo in Rated R And the winner is... Boots No7 ' + 
    'Advanced Renewal Anti-ageing Glycolic Peel Kit ($25 amazon.com) won most-appealing peel.');
  for LToken in LTokens do
  begin
    Status(LToken.Fragment);
  end; 
end;

procedure TestTDoubleArrayTrie.SetUp;
begin
  FDoubleArrayTrie := TDoubleArrayTrie.Create;
end;

procedure TestTDoubleArrayTrie.TearDown;
begin
  FDoubleArrayTrie.Free;
  FDoubleArrayTrie := nil;
end;

procedure TestTDoubleArrayTrie.PressTest;
const
  RES      = '..\..\Resource\dictionary_Small.txt';
  PRESSURE = 100000;
var
  LKeys, LText: string;
  LWatch: TStopwatch;
  I: Integer;
  LBlack: Boolean;
begin
  LWatch := TStopwatch.StartNew;
  FDoubleArrayTrie.Init(RES);

  LText := '一词T%^he 两!@#$#%%^^*词qu %^ick 啊哈哈!@#$#三词br%^　own 第!@#$#四次fox' +
    '五jum!@#$#ps词 六ov!@#$#er词 7词th!@#$#e 8词la!@#$#zy 9词do!@#$#g';
  LWatch := TStopwatch.StartNew;
  for I := 0 to PRESSURE do
    LBlack := FDoubleArrayTrie.HasBlackWord(LText);
  Status(Format('HasBlackWord: 语句长度 %d, %d次耗时 %d ms 是否有屏蔽字-%s', [LText.Length, PRESSURE,
    LWatch.ElapsedMilliseconds, BoolToStr(LBlack)]));

  LWatch := TStopwatch.StartNew;
  for I := 0 to PRESSURE do
    LKeys := FDoubleArrayTrie.Filter(LText);
  Status(Format('Filter: 语句长度 %d, %d次耗时 %d ms', [LText.Length, PRESSURE,
    LWatch.ElapsedMilliseconds]));
  Status(LKeys);
end;

initialization

RegisterTest(TestTInterval.Suite);
RegisterTest(TestTIntervalTree.Suite);
RegisterTest(TestTEmit.Suite);
RegisterTest(TestTState.Suite);
RegisterTest(TestTTrie.Suite);
RegisterTest(TestTDoubleArrayTrie.Suite);

end.
